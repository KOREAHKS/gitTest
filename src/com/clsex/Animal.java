package com.clsex;

//이 클래스는 개,고양이,오리의 부모 클래스로 정의될 예정입니다.
//원래는 부모 클래스를 먼저 정의하고, 자식을 확장(extends) 해야 하는데, 강의 흐름상 거꾸로 했습니다.
/*
 * 상속(Inheritance) : 객체지향에서 상속은 매우 중요합니다. 
 * 상속이라는것은, 기본적으로 부모가 가진 모든것을 자식이 내려받는 형태입니다. 하지만, 내려 받는것중 안되는것이 있는데,
 * 1.생성자는 상속이 되질 않습니다. 2.private 으로 선언된 것 또한 상속이 되질 않습니다.(정확히는 접근이 불가능 합니다.)
 * 
 * 이 외에는 모두 상속을 받습니다.
 * 
 * 상속이라는 개념은 실제적으로 확장 이라는 개념으로 생각해야 편합니다.
 * 부모가 가진 속성과 메서드 외에 나중에 추가될 속성과 메서드가 있다면, 기존 클래스를 뜯어 고치는게 아니라, 연관성이 분명하다면
 * 상속을 통해 자식이 그 확장 개념을 정의 한다라고 생각하면 편합니다.
 * 
 * 이렇게 상속을 통해 클래스를 확장 할 수 있는데, 하나의 부모는 하나 이상의 자식 클래스를 둘 수 있지만, 자식은 반드시 하나의 부모 클래스만 상속 받을 수 있습니다.
 * 
 * 상속은 자식이 부모를 상속 하겠다는 키워드로 선언 하는데, extends 를 사용합니다.
 */

/*
 *   추상화 (Abstraction) : 추상화란 개념은, 특정 클래스의 메서드가 자신을 위한것이 아닌 상속이 주목적인 클래스에 대해서 적용되는 설계기법
 *   예를 들면, 클래스를 정의하는 목적이 자신의 인스턴스(객체)를 생성해서 메서드 등을 이용하는게 아닌, 상속이 주 목적인 경우엔,
 *   자신의 클래스는 추상 클래스로 선언하고, 자식이 자신의 클래스를 상속받아, 추상 메서드를 반드시 오버라이드 하도록 하는데 있다.
 *   추상클래스는 문법적으로, 위의 설명의 목적에 따라, 메서드의 기능만 상속 하는데에 초점이 있기 때문에, 메서드를 정의 하지 않는다.
 *   때문에 메서드의 body가 없이, 선언부만 갖게 된다. 이렇게 선언부만 갖게 되는 메서드는 추상 메서드라고 선언을 해줘야 하는데,
 *   이때 사용되는 키워드가 abstract 이다.
 *   
 *   이렇게 추상메서드를 하나이상 보유한 클래스는 반드시 추상 클래스로 선언이 되어야 하며(안그럼 에러), 이를 상속 받은 자식클래스는 
 *   반드시 추상메서드를 오버라이드 하거나, 하지 않을시엔 자신도 추상 클래스로 선언 되어야 한다.
 *   
 *   이렇게 추상화를 하는 주 목적은, 상속되어진 메서드를 반드시 오버라이드 하도록 강제화 하는데 있다.
 *   
 *   이런 추상메서드를 보유한 추상 클래스는, 자신의 인스턴스를 생성할 수 없고, 즉 자신의 객체를 생성할 수 없고, super type으로만
 *   존재할 수 있다.
 *   
 *   이런 추상화 개념은 객체지향의 중요한 개념이 다형성을 수행하는데에 있다.
 */


public abstract class Animal {

	public String aType; //상속받은 객체가 어떤 타입(Dog, Cat, Duck) 인지를 초기화 하는 필드 선언
	
	//만약 부모가 생성자를 하나 이상 정의하면, 기본 생성자가 사라지기 때문에, 자식은 명시적으로 부모의 생성자중 하나를 호출 해야 함.
	public Animal(String aType) {
		this.aType = aType;
	}
	
	//어떤 동물인지를 String 으로 리턴하는 메서드 정의합니다.
	@Override
	public String toString() {
		return super.toString() + " 이것은 " + aType;
	}
//	public String toString() {
//		
//	}
	
	//내용부는 자식이 필요없는 부분이기 때문에, 설계적인 목적으로는 추상화의 대상이 된다.
	public abstract void sound();
}
